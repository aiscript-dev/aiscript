## API Report File for "@syuilo/aiscript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// Warning: (ae-forgotten-export) The symbol "NodeBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AddAssign = NodeBase & {
    type: 'addAssign';
    dest: Expression;
    expr: Expression;
};

// Warning: (ae-forgotten-export) The symbol "NodeBase_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AddAssign_2 = NodeBase_2 & {
    type: 'addAssign';
    dest: Expression_2;
    expr: Expression_2;
};

// @public (undocumented)
export const AISCRIPT_VERSION: "0.18.0";

// @public (undocumented)
abstract class AiScriptError extends Error {
    constructor(message: string, info?: any);
    // (undocumented)
    info?: any;
    // (undocumented)
    name: string;
}

// @public
class AiScriptIndexOutOfRangeError extends AiScriptRuntimeError {
    constructor(message: string, info?: any);
}

// @public
class AiScriptRuntimeError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptSyntaxError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptTypeError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptUserError extends AiScriptRuntimeError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
type And = NodeBase & {
    type: 'and';
    left: Expression;
    right: Expression;
};

// @public (undocumented)
type And_2 = NodeBase_2 & {
    type: 'and';
    left: Expression_2;
    right: Expression_2;
};

// @public (undocumented)
const ARR: (arr: VArr['value']) => VArr;

// @public (undocumented)
type Arr = NodeBase & {
    type: 'arr';
    value: Expression[];
};

// Warning: (ae-forgotten-export) The symbol "ChainProp" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Arr_2 = NodeBase_2 & ChainProp & {
    type: 'arr';
    value: Expression_2[];
};

// @public (undocumented)
function assertArray(val: Value | null | undefined): asserts val is VArr;

// @public (undocumented)
function assertBoolean(val: Value | null | undefined): asserts val is VBool;

// @public (undocumented)
function assertFunction(val: Value | null | undefined): asserts val is VFn;

// @public (undocumented)
function assertNumber(val: Value | null | undefined): asserts val is VNum;

// @public (undocumented)
function assertObject(val: Value | null | undefined): asserts val is VObj;

// @public (undocumented)
function assertString(val: Value | null | undefined): asserts val is VStr;

// @public (undocumented)
type Assign = NodeBase & {
    type: 'assign';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
type Assign_2 = NodeBase_2 & {
    type: 'assign';
    dest: Expression_2;
    expr: Expression_2;
};

declare namespace Ast {
    export {
        isStatement,
        isExpression,
        Loc,
        Node_2 as Node,
        Statement,
        Expression,
        Namespace,
        Meta,
        Definition,
        Attribute,
        Return,
        Each,
        For,
        Loop,
        Break,
        Continue,
        AddAssign,
        SubAssign,
        Assign,
        Not,
        And,
        Or,
        If,
        Fn,
        Match,
        Block,
        Exists,
        Tmpl,
        Str,
        Num,
        Bool,
        Null,
        Obj,
        Arr,
        Identifier,
        Call,
        Index,
        Prop,
        TypeSource,
        NamedTypeSource,
        FnTypeSource
    }
}
export { Ast }

// @public (undocumented)
type Attr_2 = {
    attr?: {
        name: string;
        value: Value;
    }[];
};

// @public (undocumented)
type Attribute = NodeBase & {
    type: 'attr';
    name: string;
    value: Expression;
};

// @public (undocumented)
type Attribute_2 = NodeBase_2 & {
    type: 'attr';
    name: string;
    value: Expression_2;
};

// @public (undocumented)
type Block = NodeBase & {
    type: 'block';
    statements: (Statement | Expression)[];
};

// @public (undocumented)
type Block_2 = NodeBase_2 & ChainProp & {
    type: 'block';
    statements: (Statement_2 | Expression_2)[];
};

// @public (undocumented)
const BOOL: (bool: VBool['value']) => VBool;

// @public (undocumented)
type Bool = NodeBase & {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type Bool_2 = NodeBase_2 & ChainProp & {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
const BREAK: () => Value;

// @public (undocumented)
type Break = NodeBase & {
    type: 'break';
};

// @public (undocumented)
type Break_2 = NodeBase_2 & {
    type: 'break';
};

// @public (undocumented)
function CALL(target: Call_2['target'], args: Call_2['args'], loc?: {
    start: number;
    end: number;
}): Call_2;

// @public (undocumented)
type Call = NodeBase & {
    type: 'call';
    target: Expression;
    args: Expression[];
};

// @public (undocumented)
type Call_2 = NodeBase_2 & {
    type: 'call';
    target: Expression_2;
    args: Expression_2[];
};

// @public (undocumented)
type CallChain = NodeBase_2 & {
    type: 'callChain';
    args: Expression_2[];
};

// @public (undocumented)
type ChainMember = CallChain | IndexChain | PropChain;

// @public (undocumented)
const CONTINUE: () => Value;

// @public (undocumented)
type Continue = NodeBase & {
    type: 'continue';
};

// @public (undocumented)
type Continue_2 = NodeBase_2 & {
    type: 'continue';
};

declare namespace Cst {
    export {
        isStatement_2 as isStatement,
        isExpression_2 as isExpression,
        hasChainProp,
        CALL,
        INDEX,
        PROP,
        Node_3 as Node,
        Statement_2 as Statement,
        Expression_2 as Expression,
        Namespace_2 as Namespace,
        Meta_2 as Meta,
        Definition_2 as Definition,
        Attribute_2 as Attribute,
        Return_2 as Return,
        Each_2 as Each,
        For_2 as For,
        Loop_2 as Loop,
        Break_2 as Break,
        Continue_2 as Continue,
        AddAssign_2 as AddAssign,
        SubAssign_2 as SubAssign,
        Assign_2 as Assign,
        InfixOperator,
        Infix,
        Not_2 as Not,
        And_2 as And,
        Or_2 as Or,
        If_2 as If,
        Fn_2 as Fn,
        Match_2 as Match,
        Block_2 as Block,
        Exists_2 as Exists,
        Tmpl_2 as Tmpl,
        Str_2 as Str,
        Num_2 as Num,
        Bool_2 as Bool,
        Null_2 as Null,
        Obj_2 as Obj,
        Arr_2 as Arr,
        Identifier_2 as Identifier,
        ChainMember,
        CallChain,
        IndexChain,
        PropChain,
        Call_2 as Call,
        Index_2 as Index,
        Prop_2 as Prop,
        TypeSource_2 as TypeSource,
        NamedTypeSource_2 as NamedTypeSource,
        FnTypeSource_2 as FnTypeSource
    }
}
export { Cst }

// @public (undocumented)
type Definition = NodeBase & {
    type: 'def';
    name: string;
    varType?: TypeSource;
    expr: Expression;
    mut: boolean;
    attr: Attribute[];
};

// @public (undocumented)
type Definition_2 = NodeBase_2 & {
    type: 'def';
    name: string;
    varType?: TypeSource_2;
    expr: Expression_2;
    mut: boolean;
    attr?: Attribute_2[];
};

// @public (undocumented)
type Each = NodeBase & {
    type: 'each';
    var: string;
    items: Expression;
    for: Statement | Expression;
};

// @public (undocumented)
type Each_2 = NodeBase_2 & {
    type: 'each';
    var: string;
    items: Expression_2;
    for: Statement_2 | Expression_2;
};

// @public (undocumented)
function eq(a: Value, b: Value): boolean;

// @public (undocumented)
const ERROR: (name: string, info?: Value) => Value;

declare namespace errors {
    export {
        AiScriptError,
        NonAiScriptError,
        AiScriptSyntaxError,
        AiScriptTypeError,
        AiScriptRuntimeError,
        AiScriptIndexOutOfRangeError,
        AiScriptUserError
    }
}
export { errors }

// @public (undocumented)
type Exists = NodeBase & {
    type: 'exists';
    identifier: Identifier;
};

// @public (undocumented)
type Exists_2 = NodeBase_2 & ChainProp & {
    type: 'exists';
    identifier: Identifier_2;
};

// @public (undocumented)
function expectAny(val: Value | null | undefined): asserts val is Value;

// @public (undocumented)
type Expression = If | Fn | Match | Block | Exists | Tmpl | Str | Num | Bool | Null | Obj | Arr | Not | And | Or | Identifier | Call | Index | Prop;

// @public (undocumented)
type Expression_2 = Infix | Not_2 | And_2 | Or_2 | If_2 | Fn_2 | Match_2 | Block_2 | Exists_2 | Tmpl_2 | Str_2 | Num_2 | Bool_2 | Null_2 | Obj_2 | Arr_2 | Identifier_2 | Call_2 | // IR
Index_2 | // IR
Prop_2;

// @public (undocumented)
const FALSE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const FN: (args: VFn['args'], statements: VFn['statements'], scope: VFn['scope']) => VFn;

// @public (undocumented)
type Fn = NodeBase & {
    type: 'fn';
    args: {
        name: string;
        argType?: TypeSource;
    }[];
    retType?: TypeSource;
    children: (Statement | Expression)[];
};

// @public (undocumented)
type Fn_2 = NodeBase_2 & ChainProp & {
    type: 'fn';
    args: {
        name: string;
        argType?: TypeSource_2;
    }[];
    retType?: TypeSource_2;
    children: (Statement_2 | Expression_2)[];
};

// @public (undocumented)
const FN_NATIVE: (fn: VFn['native']) => VFn;

// @public (undocumented)
type FnTypeSource = NodeBase & {
    type: 'fnTypeSource';
    args: TypeSource[];
    result: TypeSource;
};

// @public (undocumented)
type FnTypeSource_2 = NodeBase_2 & {
    type: 'fnTypeSource';
    args: TypeSource_2[];
    result: TypeSource_2;
};

// @public (undocumented)
type For = NodeBase & {
    type: 'for';
    var?: string;
    from?: Expression;
    to?: Expression;
    times?: Expression;
    for: Statement | Expression;
};

// @public (undocumented)
type For_2 = NodeBase_2 & {
    type: 'for';
    var?: string;
    from?: Expression_2;
    to?: Expression_2;
    times?: Expression_2;
    for: Statement_2 | Expression_2;
};

// @public (undocumented)
function getLangVersion(input: string): string | null;

// @public (undocumented)
function hasChainProp<T extends Node_3>(x: T): x is T & ChainProp;

// @public (undocumented)
type Identifier = NodeBase & {
    type: 'identifier';
    name: string;
};

// @public (undocumented)
type Identifier_2 = NodeBase_2 & ChainProp & {
    type: 'identifier';
    name: string;
};

// @public (undocumented)
type If = NodeBase & {
    type: 'if';
    cond: Expression;
    then: Statement | Expression;
    elseif: {
        cond: Expression;
        then: Statement | Expression;
    }[];
    else?: Statement | Expression;
};

// @public (undocumented)
type If_2 = NodeBase_2 & {
    type: 'if';
    cond: Expression_2;
    then: Statement_2 | Expression_2;
    elseif: {
        cond: Expression_2;
        then: Statement_2 | Expression_2;
    }[];
    else?: Statement_2 | Expression_2;
};

// @public (undocumented)
function INDEX(target: Index_2['target'], index: Index_2['index'], loc?: {
    start: number;
    end: number;
}): Index_2;

// @public (undocumented)
type Index = NodeBase & {
    type: 'index';
    target: Expression;
    index: Expression;
};

// @public (undocumented)
type Index_2 = NodeBase_2 & {
    type: 'index';
    target: Expression_2;
    index: Expression_2;
};

// @public (undocumented)
type IndexChain = NodeBase_2 & {
    type: 'indexChain';
    index: Expression_2;
};

// @public (undocumented)
type Infix = NodeBase_2 & {
    type: 'infix';
    operands: Expression_2[];
    operators: InfixOperator[];
};

// @public (undocumented)
type InfixOperator = '||' | '&&' | '==' | '!=' | '<=' | '>=' | '<' | '>' | '+' | '-' | '*' | '^' | '/' | '%';

// @public (undocumented)
export class Interpreter {
    constructor(consts: Record<string, Value>, opts?: {
        in?(q: string): Promise<string>;
        out?(value: Value): void;
        err?(e: AiScriptError): void;
        log?(type: string, params: Record<string, any>): void;
        maxStep?: number;
    });
    // (undocumented)
    abort(): void;
    // (undocumented)
    static collectMetadata(script?: Ast.Node[]): Map<any, any> | undefined;
    // (undocumented)
    exec(script?: Ast.Node[]): Promise<void>;
    execFn(fn: VFn, args: Value[]): Promise<Value>;
    execFnSimple(fn: VFn, args: Value[]): Promise<Value>;
    // (undocumented)
    registerAbortHandler(handler: () => void): void;
    // (undocumented)
    scope: Scope;
    // (undocumented)
    stepCount: number;
    // (undocumented)
    unregisterAbortHandler(handler: () => void): void;
}

// @public (undocumented)
function isArray(val: Value): val is VArr;

// @public (undocumented)
function isBoolean(val: Value): val is VBool;

// @public (undocumented)
function isExpression(x: Node_2): x is Expression;

// @public (undocumented)
function isExpression_2(x: Node_3): x is Expression_2;

// @public (undocumented)
function isFunction(val: Value): val is VFn;

// @public (undocumented)
function isNumber(val: Value): val is VNum;

// @public (undocumented)
function isObject(val: Value): val is VObj;

// @public (undocumented)
function isStatement(x: Node_2): x is Statement;

// @public (undocumented)
function isStatement_2(x: Node_3): x is Statement_2;

// @public (undocumented)
function isString(val: Value): val is VStr;

// @public (undocumented)
function jsToVal(val: any): Value;

// @public
type Loc = {
    start: number;
    end: number;
};

// @public (undocumented)
type Loop = NodeBase & {
    type: 'loop';
    statements: (Statement | Expression)[];
};

// @public (undocumented)
type Loop_2 = NodeBase_2 & {
    type: 'loop';
    statements: (Statement_2 | Expression_2)[];
};

// @public (undocumented)
type Match = NodeBase & {
    type: 'match';
    about: Expression;
    qs: {
        q: Expression;
        a: Statement | Expression;
    }[];
    default?: Statement | Expression;
};

// @public (undocumented)
type Match_2 = NodeBase_2 & ChainProp & {
    type: 'match';
    about: Expression_2;
    qs: {
        q: Expression_2;
        a: Statement_2 | Expression_2;
    }[];
    default?: Statement_2 | Expression_2;
};

// @public (undocumented)
type Meta = NodeBase & {
    type: 'meta';
    name: string | null;
    value: Expression;
};

// @public (undocumented)
type Meta_2 = NodeBase_2 & {
    type: 'meta';
    name: string | null;
    value: Expression_2;
};

// @public (undocumented)
type NamedTypeSource = NodeBase & {
    type: 'namedTypeSource';
    name: string;
    inner?: TypeSource;
};

// @public (undocumented)
type NamedTypeSource_2 = NodeBase_2 & {
    type: 'namedTypeSource';
    name: string;
    inner?: TypeSource_2;
};

// @public (undocumented)
type Namespace = NodeBase & {
    type: 'ns';
    name: string;
    members: (Definition | Namespace)[];
};

// @public (undocumented)
type Namespace_2 = NodeBase_2 & {
    type: 'ns';
    name: string;
    members: (Definition_2 | Namespace_2)[];
};

// @public (undocumented)
type Node_2 = Namespace | Meta | Statement | Expression | TypeSource;

// @public
type Node_3 = Namespace_2 | Meta_2 | Statement_2 | Expression_2 | ChainMember | TypeSource_2;

// @public
class NonAiScriptError extends AiScriptError {
    constructor(error: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
type Not = NodeBase & {
    type: 'not';
    expr: Expression;
};

// @public (undocumented)
type Not_2 = NodeBase_2 & {
    type: 'not';
    expr: Expression_2;
};

// @public (undocumented)
const NULL: {
    type: "null";
};

// @public (undocumented)
type Null = NodeBase & {
    type: 'null';
};

// @public (undocumented)
type Null_2 = NodeBase_2 & ChainProp & {
    type: 'null';
};

// @public (undocumented)
const NUM: (num: VNum['value']) => VNum;

// @public (undocumented)
type Num = NodeBase & {
    type: 'num';
    value: number;
};

// @public (undocumented)
type Num_2 = NodeBase_2 & ChainProp & {
    type: 'num';
    value: number;
};

// @public (undocumented)
const OBJ: (obj: VObj['value']) => VObj;

// @public (undocumented)
type Obj = NodeBase & {
    type: 'obj';
    value: Map<string, Expression>;
};

// @public (undocumented)
type Obj_2 = NodeBase_2 & ChainProp & {
    type: 'obj';
    value: Map<string, Expression_2>;
};

// @public (undocumented)
type Or = NodeBase & {
    type: 'or';
    left: Expression;
    right: Expression;
};

// @public (undocumented)
type Or_2 = NodeBase_2 & {
    type: 'or';
    left: Expression_2;
    right: Expression_2;
};

// @public (undocumented)
export class Parser {
    constructor();
    // (undocumented)
    addPlugin(type: PluginType, plugin: ParserPlugin): void;
    // (undocumented)
    static parse(input: string): Ast.Node[];
    // (undocumented)
    parse(input: string): Ast.Node[];
}

// @public (undocumented)
export type ParserPlugin = (nodes: Cst.Node[]) => Cst.Node[];

// @public (undocumented)
export type PluginType = 'validate' | 'transform';

// @public (undocumented)
function PROP(target: Prop_2['target'], name: Prop_2['name'], loc?: {
    start: number;
    end: number;
}): Prop_2;

// @public (undocumented)
type Prop = NodeBase & {
    type: 'prop';
    target: Expression;
    name: string;
};

// @public (undocumented)
type Prop_2 = NodeBase_2 & {
    type: 'prop';
    target: Expression_2;
    name: string;
};

// @public (undocumented)
type PropChain = NodeBase_2 & {
    type: 'propChain';
    name: string;
};

// @public (undocumented)
function reprValue(value: Value, literalLike?: boolean, processedObjects?: Set<object>): string;

// @public (undocumented)
const RETURN: (v: VReturn['value']) => Value;

// @public (undocumented)
type Return = NodeBase & {
    type: 'return';
    expr: Expression;
};

// @public (undocumented)
type Return_2 = NodeBase_2 & {
    type: 'return';
    expr: Expression_2;
};

// @public (undocumented)
export class Scope {
    constructor(layerdStates?: Scope['layerdStates'], parent?: Scope, name?: Scope['name']);
    add(name: string, variable: Variable): void;
    assign(name: string, val: Value): void;
    // Warning: (ae-forgotten-export) The symbol "Variable" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    createChildScope(states?: Map<string, Variable>, name?: Scope['name']): Scope;
    exists(name: string): boolean;
    get(name: string): Value;
    getAll(): Map<string, Variable>;
    // (undocumented)
    name: string;
    // (undocumented)
    opts: {
        log?(type: string, params: Record<string, any>): void;
        onUpdated?(name: string, value: Value): void;
    };
}

// @public (undocumented)
type Statement = Definition | Return | Each | For | Loop | Break | Continue | Assign | AddAssign | SubAssign;

// @public (undocumented)
type Statement_2 = Definition_2 | Return_2 | Attribute_2 | // AST
Each_2 | For_2 | Loop_2 | Break_2 | Continue_2 | Assign_2 | AddAssign_2 | SubAssign_2;

// @public (undocumented)
const STR: (str: VStr['value']) => VStr;

// @public (undocumented)
type Str = NodeBase & {
    type: 'str';
    value: string;
};

// @public (undocumented)
type Str_2 = NodeBase_2 & ChainProp & {
    type: 'str';
    value: string;
};

// @public (undocumented)
type SubAssign = NodeBase & {
    type: 'subAssign';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
type SubAssign_2 = NodeBase_2 & {
    type: 'subAssign';
    dest: Expression_2;
    expr: Expression_2;
};

// @public (undocumented)
type Tmpl = NodeBase & {
    type: 'tmpl';
    tmpl: (string | Expression)[];
};

// @public (undocumented)
type Tmpl_2 = NodeBase_2 & ChainProp & {
    type: 'tmpl';
    tmpl: (string | Expression_2)[];
};

// @public (undocumented)
const TRUE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
type TypeSource = NamedTypeSource | FnTypeSource;

// @public (undocumented)
type TypeSource_2 = NamedTypeSource_2 | FnTypeSource_2;

// @public (undocumented)
const unWrapRet: (v: Value) => Value;

declare namespace utils {
    export {
        expectAny,
        assertBoolean,
        assertFunction,
        assertString,
        assertNumber,
        assertObject,
        assertArray,
        isBoolean,
        isFunction,
        isString,
        isNumber,
        isObject,
        isArray,
        eq,
        valToString,
        valToJs,
        jsToVal,
        getLangVersion,
        reprValue
    }
}
export { utils }

// @public (undocumented)
function valToJs(val: Value): any;

// @public (undocumented)
function valToString(val: Value, simple?: boolean): string;

// @public (undocumented)
type Value = (VNull | VBool | VNum | VStr | VArr | VObj | VFn | VReturn | VBreak | VContinue | VError) & Attr_2;

declare namespace values {
    export {
        VNull,
        VBool,
        VNum,
        VStr,
        VArr,
        VObj,
        VFn,
        VReturn,
        VBreak,
        VContinue,
        VError,
        Attr_2 as Attr,
        Value,
        NULL,
        TRUE,
        FALSE,
        NUM,
        STR,
        BOOL,
        OBJ,
        ARR,
        FN,
        FN_NATIVE,
        RETURN,
        BREAK,
        CONTINUE,
        unWrapRet,
        ERROR
    }
}
export { values }

// @public (undocumented)
type VArr = {
    type: 'arr';
    value: Value[];
};

// @public (undocumented)
type VBool = {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type VBreak = {
    type: 'break';
    value: null;
};

// @public (undocumented)
type VContinue = {
    type: 'continue';
    value: null;
};

// @public (undocumented)
type VError = {
    type: 'error';
    value: string;
    info?: Value;
};

// @public
type VFn = {
    type: 'fn';
    args?: string[];
    statements?: Node_2[];
    native?: (args: (Value | undefined)[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        topCall: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void;
    scope?: Scope;
};

// @public (undocumented)
type VNull = {
    type: 'null';
};

// @public (undocumented)
type VNum = {
    type: 'num';
    value: number;
};

// @public (undocumented)
type VObj = {
    type: 'obj';
    value: Map<string, Value>;
};

// @public (undocumented)
type VReturn = {
    type: 'return';
    value: Value;
};

// @public (undocumented)
type VStr = {
    type: 'str';
    value: string;
};

// (No @packageDocumentation comment for this package)

```
