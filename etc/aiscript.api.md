## API Report File for "@syuilo/aiscript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// Warning: (ae-forgotten-export) The symbol "NodeBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AddAssign = NodeBase & {
    type: 'inc';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
export class AiScriptError extends Error {
    constructor(message: string, info?: any);
    // (undocumented)
    info?: any;
}

// @public (undocumented)
const ARR: (arr: VArr['value']) => {
    type: "arr";
    value: Value[];
};

// @public (undocumented)
type Arr = NodeBase & {
    type: 'arr';
    value: Expression[];
};

// @public (undocumented)
function assertArray(val: Value | null | undefined): asserts val is VArr;

// @public (undocumented)
function assertBoolean(val: Value | null | undefined): asserts val is VBool;

// @public (undocumented)
function assertFunction(val: Value | null | undefined): asserts val is VFn;

// @public (undocumented)
function assertNumber(val: Value | null | undefined): asserts val is VNum;

// @public (undocumented)
function assertObject(val: Value | null | undefined): asserts val is VObj;

// @public (undocumented)
function assertString(val: Value | null | undefined): asserts val is VStr;

// @public (undocumented)
type Assign = NodeBase & {
    type: 'assign';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
type Attr_2 = {
    attr?: {
        name: string;
        value: Value;
    }[];
};

// @public (undocumented)
type Attribute = NodeBase & {
    type: 'attr';
    name: string;
    value: Expression;
};

// @public (undocumented)
type Block = NodeBase & {
    type: 'block';
    statements: (Statement | Expression)[];
};

// @public (undocumented)
const BOOL: (bool: VBool['value']) => {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
type Bool = NodeBase & {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
const BREAK: () => {
    type: "break";
    value: null;
};

// @public (undocumented)
type Break = NodeBase & {
    type: 'break';
};

// @public (undocumented)
type Call = NodeBase & {
    type: 'call';
    target: Expression;
    args: Expression[];
};

// @public (undocumented)
const CONTINUE: () => {
    type: "continue";
    value: null;
};

// @public (undocumented)
type Continue = NodeBase & {
    type: 'continue';
};

// @public (undocumented)
type Definition = NodeBase & {
    type: 'def';
    name: string;
    varType?: TypeSource;
    expr: Expression;
    mut: boolean;
    attr: Attribute[];
};

// @public (undocumented)
type Each = NodeBase & {
    type: 'forOf';
    var: string;
    items: Expression;
    for: Statement | Expression;
};

// @public (undocumented)
function eq(a: Value, b: Value): boolean;

// @public (undocumented)
function expectAny(val: Value | null | undefined): asserts val is Value;

// @public (undocumented)
type Expression = Infix | If | Fn | Match | Block | Tmpl | Str | Num | Bool | Null | Obj | Arr | Var | Call | Index | Prop;

// @public (undocumented)
const FALSE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const FN: (args: VFn['args'], statements: VFn['statements'], scope: VFn['scope']) => {
    type: "fn";
    args: string[] | undefined;
    statements: Node_2[] | undefined;
    scope: Scope | undefined;
};

// @public (undocumented)
type Fn = NodeBase & {
    type: 'fn';
    args: {
        name: string;
        type?: TypeSource;
    }[];
    ret?: TypeSource;
    children: (Statement | Expression)[];
};

// @public (undocumented)
const FN_NATIVE: (fn: VFn['native']) => {
    type: "fn";
    native: ((args: (Value | undefined)[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void) | undefined;
};

// @public (undocumented)
type For = NodeBase & {
    type: 'for';
    var?: string;
    from?: Expression;
    to?: Expression;
    times?: Expression;
    for: Statement | Expression;
};

// @public (undocumented)
function getLangVersion(input: string): string | null;

// @public (undocumented)
type If = NodeBase & {
    type: 'if';
    cond: Expression;
    then: Statement | Expression;
    elseif: {
        cond: Expression;
        then: Statement | Expression;
    }[];
    else?: Statement | Expression;
};

// @public (undocumented)
type Index = NodeBase & {
    type: 'index';
    target: Expression;
    index: Expression;
};

// @public (undocumented)
type Infix = NodeBase & {
    type: 'infix';
    operands: Expression[];
    operators: InfixOperator[];
};

// @public (undocumented)
type InfixOperator = "||" | "&&" | "==" | "!=" | "<=" | ">=" | "<" | ">" | "+" | "-" | "*" | "|" | "%";

// @public (undocumented)
export class Interpreter {
    constructor(vars: Interpreter['vars'], opts?: Interpreter['opts']);
    // (undocumented)
    abort(): void;
    // (undocumented)
    static collectMetadata(script?: N.Node[]): Map<any, any> | undefined;
    // (undocumented)
    exec(script?: N.Node[]): Promise<void>;
    // (undocumented)
    execFn(fn: VFn, args: Value[]): Promise<Value>;
    // (undocumented)
    registerAbortHandler(handler: () => void): void;
    // (undocumented)
    scope: Scope;
    // (undocumented)
    stepCount: number;
    // (undocumented)
    unregisterAbortHandler(handler: () => void): void;
}

// @public (undocumented)
function isArray(val: Value): val is VArr;

// @public (undocumented)
function isBoolean(val: Value): val is VBool;

// @public (undocumented)
function isExpression(x: Node_2): x is Expression;

// @public (undocumented)
function isFunction(val: Value): val is VFn;

// @public (undocumented)
function isNumber(val: Value): val is VNum;

// @public (undocumented)
function isObject(val: Value): val is VObj;

// @public (undocumented)
function isStatement(x: Node_2): x is Statement;

// @public (undocumented)
function isString(val: Value): val is VStr;

// @public (undocumented)
function jsToVal(val: any): Value;

// @public (undocumented)
type Loc = {
    start: number;
    end: number;
};

// @public (undocumented)
type Loop = NodeBase & {
    type: 'loop';
    statements: (Statement | Expression)[];
};

// @public (undocumented)
type Match = NodeBase & {
    type: 'match';
    about: Expression;
    qs: {
        q: Expression;
        a: Statement | Expression;
    }[];
    default?: Statement | Expression;
};

// @public (undocumented)
type Meta = NodeBase & {
    type: 'meta';
    name: string | null;
    value: Expression;
};

declare namespace N {
    export {
        isStatement,
        isExpression,
        Loc,
        Node_2 as Node,
        Statement,
        Expression,
        Namespace,
        Meta,
        Definition,
        Attribute,
        Return,
        Each,
        For,
        Loop,
        Break,
        Continue,
        AddAssign,
        SubAssign,
        Assign,
        InfixOperator,
        Infix,
        If,
        Fn,
        Match,
        Block,
        Tmpl,
        Str,
        Num,
        Bool,
        Null,
        Obj,
        Arr,
        Var,
        Call,
        Index,
        Prop
    }
}
export { N }

// @public (undocumented)
type Namespace = NodeBase & {
    type: 'ns';
    name: string;
    members: (Definition | Namespace)[];
};

// @public (undocumented)
type Node_2 = Namespace | Meta | Statement | Expression;

// @public (undocumented)
const NULL: {
    type: "null";
};

// @public (undocumented)
type Null = NodeBase & {
    type: 'null';
};

// @public (undocumented)
const NUM: (num: VNum['value']) => {
    type: "num";
    value: number;
};

// @public (undocumented)
type Num = NodeBase & {
    type: 'num';
    value: number;
};

// @public (undocumented)
const OBJ: (obj: VObj['value']) => {
    type: "obj";
    value: Map<string, Value>;
};

// @public (undocumented)
type Obj = NodeBase & {
    type: 'obj';
    value: Map<string, Expression>;
};

// @public (undocumented)
type Prop = NodeBase & {
    type: 'prop';
    target: Expression;
    name: string;
};

// @public (undocumented)
const RETURN: (v: VReturn['value']) => {
    type: "return";
    value: Value;
};

// @public (undocumented)
type Return = NodeBase & {
    type: 'return';
    expr: Expression;
};

// @public (undocumented)
export class Scope {
    constructor(layerdStates?: Scope['layerdStates'], parent?: Scope, name?: Scope['name']);
    add(name: string, val: Value): void;
    assign(name: string, val: Value): void;
    // (undocumented)
    createChildScope(states?: Map<string, Value>, name?: Scope['name']): Scope;
    get(name: string): Value;
    getAll(): Map<string, Value>;
    // (undocumented)
    name: string;
    // (undocumented)
    opts: {
        log?(type: string, params: Record<string, any>): void;
        onUpdated?(name: string, value: Value): void;
    };
}

// @public (undocumented)
export class SemanticError extends Error {
    constructor(details?: string);
}

// @public (undocumented)
type Statement = Definition | Return | Each | For | Loop | Break | Continue | Assign | AddAssign | SubAssign;

// @public (undocumented)
const STR: (str: VStr['value']) => {
    type: "str";
    value: string;
};

// @public (undocumented)
type Str = NodeBase & {
    type: 'str';
    value: string;
};

// @public (undocumented)
type SubAssign = NodeBase & {
    type: 'dec';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
class SyntaxError_2 extends Error {
    constructor(details?: string);
}
export { SyntaxError_2 as SyntaxError }

// @public (undocumented)
type Tmpl = NodeBase & {
    type: 'tmpl';
    tmpl: (string | Expression)[];
};

// @public (undocumented)
const TRUE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const unWrapRet: (v: Value) => Value;

declare namespace utils {
    export {
        expectAny,
        assertBoolean,
        assertFunction,
        assertString,
        assertNumber,
        assertObject,
        assertArray,
        isBoolean,
        isFunction,
        isString,
        isNumber,
        isObject,
        isArray,
        eq,
        valToString,
        valToJs,
        jsToVal,
        getLangVersion
    }
}
export { utils }

// @public (undocumented)
function valToJs(val: Value): any;

// @public (undocumented)
function valToString(val: Value, simple?: boolean): string;

// @public (undocumented)
type Value = (VNull | VBool | VNum | VStr | VArr | VObj | VFn | VReturn | VBreak | VContinue) & Attr_2;

declare namespace values {
    export {
        VNull,
        VBool,
        VNum,
        VStr,
        VArr,
        VObj,
        VFn,
        VReturn,
        VBreak,
        VContinue,
        Attr_2 as Attr,
        Value,
        NULL,
        TRUE,
        FALSE,
        NUM,
        STR,
        BOOL,
        OBJ,
        ARR,
        FN,
        FN_NATIVE,
        RETURN,
        BREAK,
        CONTINUE,
        unWrapRet
    }
}
export { values }

// @public (undocumented)
type Var = NodeBase & {
    type: 'var';
    name: string;
};

// @public (undocumented)
type VArr = {
    type: 'arr';
    value: Value[];
};

// @public (undocumented)
type VBool = {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type VBreak = {
    type: 'break';
    value: null;
};

// @public (undocumented)
type VContinue = {
    type: 'continue';
    value: null;
};

// @public (undocumented)
type VFn = {
    type: 'fn';
    args?: string[];
    statements?: Node_2[];
    native?: (args: (Value | undefined)[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void;
    scope?: Scope;
};

// @public (undocumented)
type VNull = {
    type: 'null';
};

// @public (undocumented)
type VNum = {
    type: 'num';
    value: number;
};

// @public (undocumented)
type VObj = {
    type: 'obj';
    value: Map<string, Value>;
};

// @public (undocumented)
type VReturn = {
    type: 'return';
    value: Value;
};

// @public (undocumented)
type VStr = {
    type: 'str';
    value: string;
};

// Warnings were encountered during analysis:
//
// src/node.ts:82:2 - (ae-forgotten-export) The symbol "TypeSource" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
