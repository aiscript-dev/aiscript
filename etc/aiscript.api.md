## API Report File for "@syuilo/aiscript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export class AiScript {
    constructor(vars: AiScript['vars'], opts?: AiScript['opts']);
    // (undocumented)
    abort(): void;
    // (undocumented)
    static collectMetadata(script?: Node_2[]): Map<any, any> | undefined;
    // Warning: (ae-forgotten-export) The symbol "Node" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    exec(script?: Node_2[]): Promise<void>;
    // (undocumented)
    execFn(fn: VFn, args: Value[]): Promise<Value>;
    // (undocumented)
    registerAbortHandler(handler: () => void): void;
    // Warning: (ae-forgotten-export) The symbol "Scope" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    scope: Scope;
    // (undocumented)
    stepCount: number;
    // (undocumented)
    unregisterAbortHandler(handler: () => void): void;
}

// @public (undocumented)
const ARR: (arr: VArr['value']) => {
    type: "arr";
    value: Value[];
};

// @public (undocumented)
function assertArray(val: Value): asserts val is VArr;

// @public (undocumented)
function assertBoolean(val: Value): asserts val is VBool;

// @public (undocumented)
function assertFunction(val: Value): asserts val is VFn;

// @public (undocumented)
function assertNumber(val: Value): asserts val is VNum;

// @public (undocumented)
function assertObject(val: Value): asserts val is VObj;

// @public (undocumented)
function assertString(val: Value): asserts val is VStr;

// @public (undocumented)
const BOOL: (bool: VBool['value']) => {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const BREAK: () => {
    type: "break";
    value: null;
};

// @public (undocumented)
const CONTINUE: () => {
    type: "continue";
    value: null;
};

// Warning: (ae-forgotten-export) The symbol "Bin" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function deserialize(bin: Bin[]): Node_2[];

// @public (undocumented)
function eq(a: Value, b: Value): boolean;

// @public (undocumented)
const FALSE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const FN: (args: VFn['args'], statements: VFn['statements'], scope: VFn['scope']) => {
    type: "fn";
    args: string[] | undefined;
    statements: Node_2[] | undefined;
    scope: Scope | undefined;
};

// @public (undocumented)
const FN_NATIVE: (fn: VFn['native']) => {
    type: "fn";
    native: ((args: Value[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void) | undefined;
};

// @public (undocumented)
function jsToVal(val: any): Value;

// @public (undocumented)
function nodeToString(node: Node_2): string;

// @public (undocumented)
const NULL: {
    type: "null";
};

// @public (undocumented)
const NUM: (num: VNum['value']) => {
    type: "num";
    value: number;
};

// @public (undocumented)
const OBJ: (obj: VObj['value']) => {
    type: "obj";
    value: Map<string, Value>;
};

// @public (undocumented)
export function parse(input: string): Node_2[];

// @public (undocumented)
export class Parser {
    constructor();
    // (undocumented)
    addPlugin(plugin: ParserPlugin): void;
    // (undocumented)
    static parse(input: string): Node_2[];
    // (undocumented)
    parse(input: string): Node_2[];
}

// @public (undocumented)
export type ParserPlugin = (nodes: Node_2[]) => Node_2[];

// @public (undocumented)
const RETURN: (v: VReturn['value']) => {
    type: "return";
    value: Value;
};

// @public (undocumented)
export class SemanticError extends Error {
    constructor(details?: string);
}

// @public (undocumented)
export function serialize(ast: Node_2[]): Bin[];

// @public (undocumented)
const STR: (str: VStr['value']) => {
    type: "str";
    value: string;
};

// @public (undocumented)
class SyntaxError_2 extends Error {
    constructor(details?: string);
}
export { SyntaxError_2 as SyntaxError }

// @public (undocumented)
const TRUE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const unWrapRet: (v: Value) => Value;

declare namespace utils {
    export {
        assertBoolean,
        assertFunction,
        assertString,
        assertNumber,
        assertObject,
        assertArray,
        eq,
        valToString,
        nodeToString,
        valToJs,
        jsToVal
    }
}
export { utils }

// @public (undocumented)
function valToJs(val: Value): any;

// @public (undocumented)
function valToString(val: Value, simple?: boolean): any;

// @public (undocumented)
type Value = VNull | VBool | VNum | VStr | VArr | VObj | VFn | VReturn | VBreak | VContinue;

declare namespace values {
    export {
        VNull,
        VBool,
        VNum,
        VStr,
        VArr,
        VObj,
        VFn,
        VReturn,
        VBreak,
        VContinue,
        Value,
        NULL,
        TRUE,
        FALSE,
        NUM,
        STR,
        BOOL,
        OBJ,
        ARR,
        FN,
        FN_NATIVE,
        RETURN,
        BREAK,
        CONTINUE,
        unWrapRet
    }
}
export { values }

// @public (undocumented)
type VArr = {
    type: 'arr';
    value: Value[];
};

// @public (undocumented)
type VBool = {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type VBreak = {
    type: 'break';
    value: null;
};

// @public (undocumented)
type VContinue = {
    type: 'continue';
    value: null;
};

// @public (undocumented)
type VFn = {
    type: 'fn';
    args?: string[];
    statements?: Node_2[];
    native?: (args: Value[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void;
    scope?: Scope;
};

// @public (undocumented)
type VNull = {
    type: 'null';
};

// @public (undocumented)
type VNum = {
    type: 'num';
    value: number;
};

// @public (undocumented)
type VObj = {
    type: 'obj';
    value: Map<string, Value>;
};

// @public (undocumented)
type VReturn = {
    type: 'return';
    value: Value;
};

// @public (undocumented)
type VStr = {
    type: 'str';
    value: string;
};

// (No @packageDocumentation comment for this package)

```
