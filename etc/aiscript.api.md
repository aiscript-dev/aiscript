## API Report File for "@syuilo/aiscript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// Warning: (ae-forgotten-export) The symbol "NodeBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AddAssign = NodeBase & {
    type: 'addAssign';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
export const AISCRIPT_VERSION: "1.0.0";

// @public (undocumented)
abstract class AiScriptError extends Error {
    constructor(message: string, info?: any);
    // (undocumented)
    info?: any;
    // (undocumented)
    name: string;
    // (undocumented)
    pos?: Pos;
}

// @public
class AiScriptIndexOutOfRangeError extends AiScriptRuntimeError {
    constructor(message: string, info?: any);
}

// @public
class AiScriptNamespaceError extends AiScriptError {
    constructor(message: string, pos: Pos, info?: any);
    // (undocumented)
    name: string;
    // (undocumented)
    pos: Pos;
}

// @public
class AiScriptRuntimeError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptSyntaxError extends AiScriptError {
    constructor(message: string, pos: Pos, info?: any);
    // (undocumented)
    name: string;
    // (undocumented)
    pos: Pos;
}

// @public
class AiScriptTypeError extends AiScriptError {
    constructor(message: string, pos: Pos, info?: any);
    // (undocumented)
    name: string;
    // (undocumented)
    pos: Pos;
}

// @public
class AiScriptUserError extends AiScriptRuntimeError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
type And = NodeBase & {
    type: 'and';
    left: Expression;
    right: Expression;
    operatorLoc: Loc;
};

// @public (undocumented)
const ARR: (arr: VArr["value"]) => VArr;

// @public (undocumented)
type Arr = NodeBase & {
    type: 'arr';
    value: Expression[];
};

// @public (undocumented)
function assertArray(val: Value | null | undefined): asserts val is VArr;

// @public (undocumented)
function assertBoolean(val: Value | null | undefined): asserts val is VBool;

// @public (undocumented)
function assertFunction(val: Value | null | undefined): asserts val is VFn;

// @public (undocumented)
function assertNumber(val: Value | null | undefined): asserts val is VNum;

// @public (undocumented)
function assertObject(val: Value | null | undefined): asserts val is VObj;

// @public (undocumented)
function assertString(val: Value | null | undefined): asserts val is VStr;

// @public (undocumented)
type Assign = NodeBase & {
    type: 'assign';
    dest: Expression;
    expr: Expression;
};

declare namespace Ast {
    export {
        isStatement,
        isExpression,
        Pos,
        Loc,
        Node_2 as Node,
        Namespace,
        Meta,
        Statement,
        Definition,
        Attribute,
        Return,
        Each,
        For,
        Loop,
        Break,
        Continue,
        AddAssign,
        SubAssign,
        Assign,
        Expression,
        Not,
        And,
        Or,
        If,
        Fn,
        Match,
        Block,
        Exists,
        Tmpl,
        Str,
        Num,
        Bool,
        Null,
        Obj,
        Arr,
        Identifier,
        Call,
        Index,
        Prop,
        TypeSource,
        NamedTypeSource,
        FnTypeSource
    }
}
export { Ast }

// @public (undocumented)
type Attr_2 = {
    attr?: {
        name: string;
        value: Value;
    }[];
};

// @public (undocumented)
type Attribute = NodeBase & {
    type: 'attr';
    name: string;
    value: Expression;
};

// @public (undocumented)
type Block = NodeBase & {
    type: 'block';
    statements: (Statement | Expression)[];
};

// @public (undocumented)
const BOOL: (bool: VBool["value"]) => VBool;

// @public (undocumented)
type Bool = NodeBase & {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
const BREAK: () => Value;

// @public (undocumented)
type Break = NodeBase & {
    type: 'break';
};

// @public (undocumented)
type Call = NodeBase & {
    type: 'call';
    target: Expression;
    args: Expression[];
};

// @public (undocumented)
const CONTINUE: () => Value;

// @public (undocumented)
type Continue = NodeBase & {
    type: 'continue';
};

// @public (undocumented)
type Definition = NodeBase & {
    type: 'def';
    name: string;
    varType?: TypeSource;
    expr: Expression;
    mut: boolean;
    attr: Attribute[];
};

// @public (undocumented)
type Each = NodeBase & {
    type: 'each';
    var: string;
    items: Expression;
    for: Statement | Expression;
};

// @public (undocumented)
function eq(a: Value, b: Value): boolean;

// @public (undocumented)
const ERROR: (name: string, info?: Value) => Value;

declare namespace errors {
    export {
        AiScriptError,
        NonAiScriptError,
        AiScriptSyntaxError,
        AiScriptTypeError,
        AiScriptNamespaceError,
        AiScriptRuntimeError,
        AiScriptIndexOutOfRangeError,
        AiScriptUserError
    }
}
export { errors }

// @public (undocumented)
type Exists = NodeBase & {
    type: 'exists';
    identifier: Identifier;
};

// @public (undocumented)
function expectAny(val: Value | null | undefined): asserts val is Value;

// @public (undocumented)
type Expression = If | Fn | Match | Block | Exists | Tmpl | Str | Num | Bool | Null | Obj | Arr | Not | And | Or | Identifier | Call | Index | Prop;

// @public (undocumented)
const FALSE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const FN: (args: VUserFn["args"], statements: VUserFn["statements"], scope: VUserFn["scope"]) => VUserFn;

// @public (undocumented)
type Fn = NodeBase & {
    type: 'fn';
    args: {
        name: string;
        optional: boolean;
        default?: Expression;
        argType?: TypeSource;
    }[];
    retType?: TypeSource;
    children: (Statement | Expression)[];
};

// @public (undocumented)
const FN_NATIVE: (fn: VNativeFn["native"]) => VNativeFn;

// @public (undocumented)
type FnTypeSource = NodeBase & {
    type: 'fnTypeSource';
    args: TypeSource[];
    result: TypeSource;
};

// @public (undocumented)
type For = NodeBase & {
    type: 'for';
    var?: string;
    from?: Expression;
    to?: Expression;
    times?: Expression;
    for: Statement | Expression;
};

// @public (undocumented)
function getLangVersion(input: string): string | null;

// @public (undocumented)
type Identifier = NodeBase & {
    type: 'identifier';
    name: string;
};

// @public (undocumented)
type If = NodeBase & {
    type: 'if';
    cond: Expression;
    then: Statement | Expression;
    elseif: {
        cond: Expression;
        then: Statement | Expression;
    }[];
    else?: Statement | Expression;
};

// @public (undocumented)
type Index = NodeBase & {
    type: 'index';
    target: Expression;
    index: Expression;
};

// @public (undocumented)
export class Interpreter {
    constructor(consts: Record<string, Value>, opts?: {
        in?(q: string): Promise<string>;
        out?(value: Value): void;
        err?(e: AiScriptError): void;
        log?(type: string, params: Record<string, any>): void;
        maxStep?: number;
        abortOnError?: boolean;
    });
    // (undocumented)
    abort(): void;
    // (undocumented)
    static collectMetadata(script?: Ast.Node[]): Map<any, any> | undefined;
    // (undocumented)
    exec(script?: Ast.Node[]): Promise<void>;
    execFn(fn: VFn, args: Value[]): Promise<Value>;
    execFnSimple(fn: VFn, args: Value[]): Promise<Value>;
    // (undocumented)
    registerAbortHandler(handler: () => void): void;
    // (undocumented)
    scope: Scope;
    // (undocumented)
    stepCount: number;
    // (undocumented)
    unregisterAbortHandler(handler: () => void): void;
}

// @public (undocumented)
function isArray(val: Value): val is VArr;

// @public (undocumented)
function isBoolean(val: Value): val is VBool;

// @public (undocumented)
function isExpression(x: Node_2): x is Expression;

// @public (undocumented)
function isFunction(val: Value): val is VFn;

// @public (undocumented)
function isNumber(val: Value): val is VNum;

// @public (undocumented)
function isObject(val: Value): val is VObj;

// @public (undocumented)
function isStatement(x: Node_2): x is Statement;

// @public (undocumented)
function isString(val: Value): val is VStr;

// @public (undocumented)
function jsToVal(val: any): Value;

// @public (undocumented)
type Loc = {
    start: Pos;
    end: Pos;
};

// @public (undocumented)
type Loop = NodeBase & {
    type: 'loop';
    statements: (Statement | Expression)[];
};

// @public (undocumented)
type Match = NodeBase & {
    type: 'match';
    about: Expression;
    qs: {
        q: Expression;
        a: Statement | Expression;
    }[];
    default?: Statement | Expression;
};

// @public (undocumented)
type Meta = NodeBase & {
    type: 'meta';
    name: string | null;
    value: Expression;
};

// @public (undocumented)
type NamedTypeSource = NodeBase & {
    type: 'namedTypeSource';
    name: string;
    inner?: TypeSource;
};

// @public (undocumented)
type Namespace = NodeBase & {
    type: 'ns';
    name: string;
    members: (Definition | Namespace)[];
};

// @public (undocumented)
type Node_2 = Namespace | Meta | Statement | Expression | TypeSource | Attribute;

// @public
class NonAiScriptError extends AiScriptError {
    constructor(error: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
type Not = NodeBase & {
    type: 'not';
    expr: Expression;
};

// @public (undocumented)
const NULL: {
    type: "null";
};

// @public (undocumented)
type Null = NodeBase & {
    type: 'null';
};

// @public (undocumented)
const NUM: (num: VNum["value"]) => VNum;

// @public (undocumented)
type Num = NodeBase & {
    type: 'num';
    value: number;
};

// @public (undocumented)
const OBJ: (obj: VObj["value"]) => VObj;

// @public (undocumented)
type Obj = NodeBase & {
    type: 'obj';
    value: Map<string, Expression>;
};

// @public (undocumented)
type Or = NodeBase & {
    type: 'or';
    left: Expression;
    right: Expression;
    operatorLoc: Loc;
};

// @public (undocumented)
export class Parser {
    constructor();
    // (undocumented)
    addPlugin(type: PluginType, plugin: ParserPlugin): void;
    // (undocumented)
    static parse(input: string): Ast.Node[];
    // (undocumented)
    parse(input: string): Ast.Node[];
}

// @public (undocumented)
export type ParserPlugin = (nodes: Ast.Node[]) => Ast.Node[];

// @public (undocumented)
export type PluginType = 'validate' | 'transform';

// @public
type Pos = {
    line: number;
    column: number;
};

// @public (undocumented)
type Prop = NodeBase & {
    type: 'prop';
    target: Expression;
    name: string;
};

// @public (undocumented)
function reprValue(value: Value, literalLike?: boolean, processedObjects?: Set<object>): string;

// @public (undocumented)
const RETURN: (v: VReturn["value"]) => Value;

// @public (undocumented)
type Return = NodeBase & {
    type: 'return';
    expr: Expression;
};

// @public (undocumented)
export class Scope {
    constructor(layerdStates?: Scope['layerdStates'], parent?: Scope, name?: Scope['name'], nsName?: string);
    add(name: string, variable: Variable): void;
    assign(name: string, val: Value): void;
    // (undocumented)
    createChildNamespaceScope(nsName: string, states?: Map<string, Variable>, name?: Scope['name']): Scope;
    // Warning: (ae-forgotten-export) The symbol "Variable" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    createChildScope(states?: Map<string, Variable>, name?: Scope['name']): Scope;
    exists(name: string): boolean;
    get(name: string): Value;
    getAll(): Map<string, Variable>;
    // (undocumented)
    name: string;
    // (undocumented)
    nsName?: string;
    // (undocumented)
    opts: {
        log?(type: string, params: Record<string, any>): void;
        onUpdated?(name: string, value: Value): void;
    };
}

// @public (undocumented)
type Statement = Definition | Return | Each | For | Loop | Break | Continue | Assign | AddAssign | SubAssign;

// @public (undocumented)
const STR: (str: VStr["value"]) => VStr;

// @public (undocumented)
type Str = NodeBase & {
    type: 'str';
    value: string;
};

// @public (undocumented)
type SubAssign = NodeBase & {
    type: 'subAssign';
    dest: Expression;
    expr: Expression;
};

// @public (undocumented)
type Tmpl = NodeBase & {
    type: 'tmpl';
    tmpl: (string | Expression)[];
};

// @public (undocumented)
const TRUE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
type TypeSource = NamedTypeSource | FnTypeSource;

// @public (undocumented)
const unWrapRet: (v: Value) => Value;

declare namespace utils {
    export {
        expectAny,
        assertBoolean,
        assertFunction,
        assertString,
        assertNumber,
        assertObject,
        assertArray,
        isBoolean,
        isFunction,
        isString,
        isNumber,
        isObject,
        isArray,
        eq,
        valToString,
        valToJs,
        jsToVal,
        getLangVersion,
        reprValue
    }
}
export { utils }

// @public (undocumented)
function valToJs(val: Value): any;

// @public (undocumented)
function valToString(val: Value, simple?: boolean): string;

// @public (undocumented)
type Value = (VNull | VBool | VNum | VStr | VArr | VObj | VFn | VReturn | VBreak | VContinue | VError) & Attr_2;

declare namespace values {
    export {
        VNull,
        VBool,
        VNum,
        VStr,
        VArr,
        VObj,
        VFn,
        VUserFn,
        VFnArg,
        VNativeFn,
        VReturn,
        VBreak,
        VContinue,
        VError,
        Attr_2 as Attr,
        Value,
        NULL,
        TRUE,
        FALSE,
        NUM,
        STR,
        BOOL,
        OBJ,
        ARR,
        FN,
        FN_NATIVE,
        RETURN,
        BREAK,
        CONTINUE,
        unWrapRet,
        ERROR
    }
}
export { values }

// @public (undocumented)
type VArr = {
    type: 'arr';
    value: Value[];
};

// @public (undocumented)
type VBool = {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type VBreak = {
    type: 'break';
    value: null;
};

// @public (undocumented)
type VContinue = {
    type: 'continue';
    value: null;
};

// @public (undocumented)
type VError = {
    type: 'error';
    value: string;
    info?: Value;
};

// @public (undocumented)
type VFn = VUserFn | VNativeFn;

// @public (undocumented)
type VFnArg = {
    name: string;
    type?: Type;
    default?: Value;
};

// @public
type VNativeFn = VFnBase & {
    native: (args: (Value | undefined)[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        topCall: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Value | Promise<Value> | void;
};

// @public (undocumented)
type VNull = {
    type: 'null';
};

// @public (undocumented)
type VNum = {
    type: 'num';
    value: number;
};

// @public (undocumented)
type VObj = {
    type: 'obj';
    value: Map<string, Value>;
};

// @public (undocumented)
type VReturn = {
    type: 'return';
    value: Value;
};

// @public (undocumented)
type VStr = {
    type: 'str';
    value: string;
};

// Warning: (ae-forgotten-export) The symbol "VFnBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type VUserFn = VFnBase & {
    native?: undefined;
    args: VFnArg[];
    statements: Node_2[];
    scope: Scope;
};

// Warnings were encountered during analysis:
//
// src/interpreter/value.ts:46:2 - (ae-forgotten-export) The symbol "Type" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
