## リテラル式
AiScriptにおけるリテラルとは、値を文字列として書き表すための表記法です。  
リテラルはスクリプト中でそのまま式として使用することができます。  
null、真理値、数値、文字列、オブジェクト、関数のリテラルが存在しています。  

### null
```js
null
```

### 真理値
```js
true
false
```

### 数値
十進以外の記数法はサポートされていません。  
```js
12 // 自然数
-34 // 負数
52.448 // 小数
```
※負数を表す`-`は数値リテラルのみで使用できます。`-variable`のような表記はサポートされていません。

### 文字列
`'`または`"`が使用可能な通常の文字列リテラルと、`` ` ``を使用し文中に式を含むことができるテンプレートリテラルがあります。

#### エスケープについて
`\`を前置した文字は、構文の一部ではなく一つの文字として解釈されます。  
例えば`'\''`は`'`、  
`"\""`では`"`、  
``` `\`` ```は`` ` ``、  
`` `\{` ``は`{`、として解釈されます。  
特に構文としての意味を持たない文字の場合、単に`\`が無視されます。例：`'\n'` → `n`  
文字`\`を使用したい場合は`'\\'`のように２つ繋げてください。  
エスケープシーケンスは未サポートです。  

#### 文字列リテラル
```js
'ここでは"を文字列に含むことができます'
"ここでは'を文字列に含むことができます"
'エスケープすれば\'を含むことができます'
"エスケープすれば\"を含むことができます"
'改行
できます'
"改行 // ここにコメントを書くと文字列の一部になります
できます" // ここは問題なし
```

#### テンプレートリテラル
変数や式を埋め込んだ文字列を作成するためのリテラルです。  
全体を`` ` ` ``で囲い、式を埋め込む場所は`{ }`で囲います。  
式の値が文字列でない場合は、[Core:to_str](./std.md)と同じ方法で文字列に変換されます。  
```js
<: `Ai chan is No.{ 2-1 }` // Ai chan is No.1
// 改行可　一行にしたい場合は{ Str:lf }を使う
`This statement is { true }.
Previous statement is { !true }.`
// \を前置することで`、{、}、をエスケープできる
`\` \{ \}` // ` { }
```
```js
// { }の中身が空であってはならない（{ }を文字列として使いたい場合はエスケープすること）
`Everything is { } here.` // Syntax Error
// 式の前後で改行をしてはならない（式中で改行するのは可）
`Oops, something went {
	'wrong'
}!` // Syntax Error
```

### 配列
```js
[] // 空の配列
[1, 1+1, 1+1+1] // コロンで区切ることも出来る
[1, 1+1, 1+1+1,] // 最後の項に,をつけてもよい
[  // 改行区切りも可
	'hoge'
	'huga'
	'piyo'
]
[  // コロンと改行の併用可
	'hoge',
	'huga',
	'piyo',
]
```
```js
[1 2 3] // 空白区切りは廃止済み
```

### オブジェクト
```js
{} // 空のオブジェクト
{ // 改行区切り
	a: 12
	b: 'hoge'
}
{a: 12,b: 'hoge'} // コロン区切り
```
```js
// 空白区切りは廃止済み
{a: 12 b: 'hoge'} // Syntax Error
// セミコロン区切りは廃止済み
{a: 12; b: 'hoge'} // Syntax Error
```

### 関数
関数のリテラルは「無名関数」と呼ばれており、[関数の宣言](./syntax.md#%E9%96%A2%E6%95%B0)とよく似た形をしていますが、関数名がありません。（そして、リテラルなので当然ながら、文ではなく式です）  
```js
var func = @(){} // 何もしない関数
// 最後の式が暗黙にreturnされる
func = @(x, y) {
	x + y
}
<: func(1, 2) // 3
// 明示的にreturnを書くこともできる
@(x, y) {
	return x + y
}
// 引数を複数行で書いてもよい
@(
	x,
	y
) {
	x + y
}
@(x,y){x+y} // ワンライナー
```

### エラー型
エラー型のリテラルはありませんが、[Error:create](./std.md)で値を作ることができます。  
